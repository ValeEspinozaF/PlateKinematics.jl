var documenterSearchIndex = {"docs":
[{"location":"lib/other_functions/","page":"Other Functions","title":"Other Functions","text":"CurrentModule = PlateKinematics","category":"page"},{"location":"lib/other_functions/#Other-Functions","page":"Other Functions","title":"Other Functions","text":"","category":"section"},{"location":"lib/other_functions/#Contents","page":"Other Functions","title":"Contents","text":"","category":"section"},{"location":"lib/other_functions/","page":"Other Functions","title":"Other Functions","text":"Pages = [\"other_functions.md\"]\nDepth = 3","category":"page"},{"location":"lib/other_functions/#Index","page":"Other Functions","title":"Index","text":"","category":"section"},{"location":"lib/other_functions/","page":"Other Functions","title":"Other Functions","text":"Pages = [\"other_functions.md\"]","category":"page"},{"location":"lib/other_functions/#Other-Functions-2","page":"Other Functions","title":"Other Functions","text":"","category":"section"},{"location":"lib/other_functions/#Coordinate-System-Transformations","page":"Other Functions","title":"Coordinate System Transformations","text":"","category":"section"},{"location":"lib/other_functions/","page":"Other Functions","title":"Other Functions","text":"ToDegrees\nToRadians\ncart2sph\nsph2cart","category":"page"},{"location":"lib/other_functions/#PlateKinematics.ToDegrees","page":"Other Functions","title":"PlateKinematics.ToDegrees","text":"ToDegrees(radValue::Union{Float64, Array})\n\nConvert angles from radians to degrees.\n\n\n\n\n\n","category":"function"},{"location":"lib/other_functions/#PlateKinematics.ToRadians","page":"Other Functions","title":"PlateKinematics.ToRadians","text":"ToRadians(degValue::Union{Float64, Array})\n\nConvert angles from degrees to radians.\n\n\n\n\n\n","category":"function"},{"location":"lib/other_functions/#PlateKinematics.cart2sph","page":"Other Functions","title":"PlateKinematics.cart2sph","text":"cart2sph(x::Float64, y::Float64, z::Float64)\ncart2sph(x::Array{N}, y::Array{N}, z::Array{N}) where {N<:Float64}\n\nTransform Cartesian coordinates into Spherical coordinates.  Both input and outputs are expressed in degrees.\n\n\n\n\n\n","category":"function"},{"location":"lib/other_functions/#PlateKinematics.sph2cart","page":"Other Functions","title":"PlateKinematics.sph2cart","text":"sph2cart(lon_deg::Float64, lat_deg::Float64, mag=1::Float64)\nsph2cart(lon_deg::Array{N}, lat_deg::Array{N}, mag::Array{N}) where {N<:Float64}\nsph2cart(lon_deg::Array{N}, lat_deg::Array{N}) where {N<:Float64}\n\nTransform Spherical coordinate(s) into Cartesian coordinate(s).  Both input and outputs are expressed in degrees. \n\n\n\n\n\n","category":"function"},{"location":"lib/other_functions/#Finite-Rotation-Transformations","page":"Other Functions","title":"Finite Rotation Transformations","text":"","category":"section"},{"location":"lib/other_functions/","page":"Other Functions","title":"Other Functions","text":"ToFRs\nToFRc\nToRotationMatrix\nToEulerAngles","category":"page"},{"location":"lib/other_functions/#PlateKinematics.ToFRs","page":"Other Functions","title":"PlateKinematics.ToFRs","text":"ToFRs(FRc::FiniteRotCart)\nToFRs(FRcArray::Array{T}) where {T<:FiniteRotCart}\nToFRs(EA::EulerAngles)\nToFRs(EA::Array{T}) where {T<:EulerAngles}\n\nReturn a Finite Rotation in Spherical coordinates (::FiniteRotSph), expressed in degrees.\n\n\n\n\n\nToFRs(MTX::Array{N, 3}, time=nothing::Union{Nothing, N}) where {N<:Float64}\n\nConvert an array of Rotation Matrices MTX to an array of Finite Rotations (::FiniteRotSph),  expressed in degrees. The :Time field may be passed with the argument time.\n\n\n\n\n\n","category":"function"},{"location":"lib/other_functions/#PlateKinematics.ToFRc","page":"Other Functions","title":"PlateKinematics.ToFRc","text":"ToFRc(FRs::FiniteRotSph)\nToFRc(FRsArray::Array{T}) where {T<:FiniteRotSph}\n\nReturn a Finite Rotation in Cartesian coordinates (::FiniteRotCart), expressed in degrees.\n\n\n\n\n\n","category":"function"},{"location":"lib/other_functions/#PlateKinematics.ToRotationMatrix","page":"Other Functions","title":"PlateKinematics.ToRotationMatrix","text":"ToRotationMatrix(FRs::FiniteRotSph)\nToRotationMatrix(FRsArray::Array{T}) where {T<:FiniteRotSph}\nToRotationMatrix(EA::Array{T}) where {T<:EulerAngles}\nToRotationMatrix(EAx::Array{N, 1}, EAy::Array{N, 1}, EAz::Array{N, 1}) where {N<:Float64}\n\nReturn a Rotation Matrix (3x3 Array) expressed in radians.\n\n\n\n\n\n","category":"function"},{"location":"lib/other_functions/#PlateKinematics.ToEulerAngles","page":"Other Functions","title":"PlateKinematics.ToEulerAngles","text":"ToEulerAngles(FRs::FiniteRotSph)\nToEulerAngles(FRsArray::Array{T}) where {T<:FiniteRotSph}\n\nReturn the set of Euler angles (::EulerAngles) from a Finite Rotation.\n\n\n\n\n\n","category":"function"},{"location":"lib/other_functions/#Euler-Vector-Transformations","page":"Other Functions","title":"Euler Vector Transformations","text":"","category":"section"},{"location":"lib/other_functions/","page":"Other Functions","title":"Other Functions","text":"ToEVs\nToEVc","category":"page"},{"location":"lib/other_functions/#PlateKinematics.ToEVs","page":"Other Functions","title":"PlateKinematics.ToEVs","text":"ToEVs(EVc::EulerVectorCart)\nToEVs(EVcArray::Array{T}) where {T<:EulerVectorSph}\nToEVs(\n    X::Array{N, 1}, Y::Array{N, 1}, Z::Array{N, 1}, \n    timeRange=nothing::Union{Nothing, Matrix{N}}) where {N<:Float64}\n\nReturn an Euler Vector in Spherical coordinates (::EulerVectorSph), with  magnitude expressed in degrees/Myr.\n\n\n\n\n\n","category":"function"},{"location":"lib/other_functions/#PlateKinematics.ToEVc","page":"Other Functions","title":"PlateKinematics.ToEVc","text":"ToEVc(EVs::EulerVectorSph)\nToEVc(EVsArray::Array{T}) where {T<:EulerVectorSph}\n\nReturn an Euler Vector in Cartesian coordinates (::EulerVectorCart), expressed in degrees/Myr.\n\n\n\n\n\n","category":"function"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"CurrentModule = PlateKinematics","category":"page"},{"location":"examples/mf_to_euler/#From-Finite-Rotation-to-Euler-Vector","page":"Convert to Euler Vector","title":"From Finite Rotation to Euler Vector","text":"","category":"section"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"Here we will go through the process of transforming a Finite Rotation, which provides the rotation angle of a Total Rotation, to an Euler Vector, which provide the rotation rate of a Stage Rotation.","category":"page"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"This process generally involves obtaining an stage Finite Rotation, and then transforming it to an Euler Vector. By general rule, we may obtain a stage Finite Rotation as:","category":"page"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"<center> <sup>t2</sup>FR<sup>t1</sup> = − <sup>0</sup>FR<sup>t2</sup> + <sup>0</sup>FR<sup>t1</sup> </center> \n<br/>","category":"page"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"This equation involves two total poles, each one a Reconstruction Rotation. Whether t1 is larger than t2 or viceversa will determine the direction of the rotation. For instance, if t1 > t2, the resulting Finite Rotation will represent a Forward Rotation, the motion from a point further back in time, to a more recent one. Else the rotation will represent a Reconstruction Rotation.","category":"page"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"The final step is to transform the Finite Rotation to an Euler Vector. This is done by dividing the rotation angle (&#937;) by the time spanned between the two total reconstructions (Δt), and hence obtaining the rotation rate (ω):","category":"page"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"<center> <sup>t2</sup>FR<sup>t1</sup>[&#937;] &#160 → &#160 <sup>t2</sup>EV<sup>t1</sup>[$\\frac{&#937;}{&#8710;t}$] &#160 → &#160 <sup>t2</sup>EV<sup>t1</sup>[ω] </center>\n<br/><br/>","category":"page"},{"location":"examples/mf_to_euler/#From-two-Finite-Rotations-(Stage-Euler-Vector)","page":"Convert to Euler Vector","title":"From two Finite Rotations (Stage Euler Vector)","text":"","category":"section"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"we start providing an example for the most general case, an Euler Vector obtained from two Finite Rotations. In this particular case, we will seek to obtain the Euler Vector describing the motion of Eurasia relative to North-America between the ages 83 to 53 Ma. The values are taken from Allan Cox' book Plate Tectonics: How it works, Table 7-1:","category":"page"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"t(Ma) Longitude(°E) Latitude(°N) Angle(°)\n37.0 129.9 68.0 -7.8\n48.0 142.8 50.8 -9.8\n53.0 145.0 40.0 -11.4\n83.0 150.1 70.5 -20.3\n90.0 152.9 75.5 -24.2","category":"page"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"using PlateKinematics\nusing PlateKinematics: FiniteRotSph, EulerVectorSph, Covariance\nusing PlateKinematics: ToEulerVector\n\nFRs_53 = FiniteRotSph(145.0, 40.0, -11.4, 53.0);\nFRs_83 = FiniteRotSph(150.1, 70.5, -20.3, 83.0);\nToEulerVector(FRs_83, FRs_53)","category":"page"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"EulerVectorSph:\n        Lon         : -75.94\n        Lat         : 78.09\n        AngVelocity : 0.4\n        TimeRange   : [83.0 53.0]\n        Covariance  : Covariance(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)","category":"page"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"Bear in mind that the Euler Vector here inherits the Time Orientation from the given order of Finite Rotations. In the above example, the Euler Vector reports the rotation from 83 Ma to 53 Ma, a Forward Rotation. If we were to reverse the order of the Finite Rotations, the Euler Vector would be defined as the rotation rate of the stage rotation from 37 Ma to 42 Ma, a Reconstruction Rotation. One could otherwise use the reverseRot keyword to reverse the time orientation of the Euler Vector:","category":"page"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"ToEulerVector(FRs_83, FRs_53, reverseRot=true)","category":"page"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"EulerVectorSph:\n        Lon         : -22.68\n        Lat         : 80.44\n        AngVelocity : 0.4\n        TimeRange   : [53.0 83.0]\n        Covariance  : Covariance(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)","category":"page"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"This derives from the negative rotation property of Finite Rotations, where in general, the time-orientation may be inverted using the antipole or the inverse of the rotation angle:","category":"page"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"<center> <sup>t2</sup><sub>A</sub>FR<sub>B</sub><sup>t1</sup> = − <sup>t1</sup><sub>A</sub>FR<sub>B</sub><sup>t2</sup> </center>\n<br/><br/>","category":"page"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"Know however that this is not generally true for inversion of the fixed plate:","category":"page"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"<center> <sup>t2</sup><sub>A</sub>FR<sub>B</sub><sup>t1</sup> ≠ − <sup>t2</sup><sub>B</sub>FR<sub>A</sub><sup>t1</sup> </center>\n<br/><br/>","category":"page"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"but rather is only true for rotations to and from the present, that is, a Total Rotation:","category":"page"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"<center> <sup>0</sup><sub>A</sub>FR<sub>B</sub><sup>t</sup> = − <sup>0</sup><sub>B</sub>FR<sub>A</sub><sup>t</sup> </center>\n<br/><br/> ","category":"page"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"A more thorough explanation of this can be found in the book Plate Tectonics: How it works.","category":"page"},{"location":"examples/mf_to_euler/#From-one-Finite-Rotation-(total-Euler-Vector)","page":"Convert to Euler Vector","title":"From one Finite Rotation (total Euler Vector)","text":"","category":"section"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"The same can be done for a single Finite Rotation, based on the general equation for stage rotations stated above: ","category":"page"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"<center> <sup>t2</sup>FR<sup>t1</sup> = − <sup>0</sup>FR<sup>t2</sup> + <sup>0</sup>FR<sup>t1</sup>, </center>\n<br/>\n\nthen t1 = 0, t2 = t, and <br/>\n\n<center> <sup>t</sup>FR<sup>0</sup> =  − <sup>0</sup>FR<sup>t</sup> + <sup>0</sup>FR<sup>0</sup> </center>\n<br/>\n<center> <sup>t</sup>FR<sup>0</sup> =  − <sup>0</sup>FR<sup>t</sup> </center>\n<br/><br/>","category":"page"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"For instance, we can obtain the Euler Vector describing the motion of North-America relative to Eurasia between the age 37 Ma and present day. ","category":"page"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"using PlateKinematics: FiniteRotSph, EulerVectorSph, Covariance\nusing PlateKinematics: ToEulerVector\n\nFRs_37 = FiniteRotSph(129.9, 68.0, 7.8, 37.0);\nToEulerVector(FRs_37)","category":"page"},{"location":"examples/mf_to_euler/","page":"Convert to Euler Vector","title":"Convert to Euler Vector","text":"EulerVectorSph:\n        Lon         : -50.1\n        Lat         : -68.0\n        AngVelocity : 0.21 \n        TimeRange   : [37.0 0.0]\n        Covariance  : Covariance(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)","category":"page"},{"location":"examples/mf_surface_velocity/","page":"Calculate Surface Velocity","title":"Calculate Surface Velocity","text":"CurrentModule = PlateKinematics","category":"page"},{"location":"examples/mf_surface_velocity/#Calculate-Surface-Velocity","page":"Calculate Surface Velocity","title":"Calculate Surface Velocity","text":"","category":"section"},{"location":"examples/mf_surface_velocity/","page":"Calculate Surface Velocity","title":"Calculate Surface Velocity","text":"For given times, it may come handy finding the local velocity of a point in the Earth surface. For that, the general expression is:","category":"page"},{"location":"examples/mf_surface_velocity/","page":"Calculate Surface Velocity","title":"Calculate Surface Velocity","text":"<center> <em>V = ω × (R P) </em> </center>\n$V = \\omega \\times (R P)$","category":"page"},{"location":"examples/mf_surface_velocity/","page":"Calculate Surface Velocity","title":"Calculate Surface Velocity","text":"where V is the velocity vector, ω is the Euler vector of rotation, R is the radius of the Earth, P is the position vector of the point in the Earth's surface.","category":"page"},{"location":"examples/mf_surface_velocity/","page":"Calculate Surface Velocity","title":"Calculate Surface Velocity","text":"Instead of a vector, Calculate_SurfaceVelocity report the velocity vector V in terms of i) northward and eastward components, ii) norm (total velocity), and iii) azimuth of the velocity vector as measured clockwise from the North. The function takes the Euler vector of rotation, and the geographical position of interest in the Earth's surface as inputs. For convenience, this point is not given as a vector (P), but rather as longitude and latitude coordinates. Calculate_SurfaceVelocity then uses the WGS-84 ellipsoid to calculate the cartesian coordinates of the position vector P. ","category":"page"},{"location":"examples/mf_surface_velocity/","page":"Calculate Surface Velocity","title":"Calculate Surface Velocity","text":"Take the following example values for the motion of the Anatolia plate relative to Eurasia, values taken from Martin de Blas et al., 2022. For the geographical position of interest, we will use coordinates close to the boundary between both plate, a structure also known as the North Anatolia Fault.","category":"page"},{"location":"examples/mf_surface_velocity/","page":"Calculate Surface Velocity","title":"Calculate Surface Velocity","text":"using PlateKinematics\nusing PlateKinematics: EulerVectorSph, SurfaceVelocityVector\nusing PlateKinematics: Calculate_SurfaceVelocity\n\nlon_NAF, lat_NAF = 33.5, 41.0;\nEVs_AT_EU = EulerVectorSph(33.44, 33.19 , 1.7);\nCalculate_SurfaceVelocity(EVs_AT_EU, lon_NAF, lat_NAF)","category":"page"},{"location":"examples/mf_surface_velocity/","page":"Calculate Surface Velocity","title":"Calculate Surface Velocity","text":"SurfaceVelocityVector:\n        Lon      : 33.5\n        Lat      : 41.0\n        EastVel  : -2.51\n        NorthVel : 0.02\n        TotalVel : 2.51\n        Azimuth  : -89.62","category":"page"},{"location":"examples/mf_surface_velocity/","page":"Calculate Surface Velocity","title":"Calculate Surface Velocity","text":"As expected, we obtain a strong eastward component, compatible with the known right-lateral strike-slip behavior of the North Anatolia Fault.","category":"page"},{"location":"lib/auxiliary_functions/","page":"Auxiliary Functions","title":"Auxiliary Functions","text":"CurrentModule = PlateKinematics","category":"page"},{"location":"lib/auxiliary_functions/#Auxiliary-Functions","page":"Auxiliary Functions","title":"Auxiliary Functions","text":"","category":"section"},{"location":"lib/auxiliary_functions/#Contents","page":"Auxiliary Functions","title":"Contents","text":"","category":"section"},{"location":"lib/auxiliary_functions/","page":"Auxiliary Functions","title":"Auxiliary Functions","text":"Pages = [\"auxiliary_functions.md\"]\nDepth = 3","category":"page"},{"location":"lib/auxiliary_functions/#Index","page":"Auxiliary Functions","title":"Index","text":"","category":"section"},{"location":"lib/auxiliary_functions/","page":"Auxiliary Functions","title":"Auxiliary Functions","text":"Pages = [\"auxiliary_functions.md\"]","category":"page"},{"location":"lib/auxiliary_functions/#Auxiliary-Functions-2","page":"Auxiliary Functions","title":"Auxiliary Functions","text":"","category":"section"},{"location":"lib/auxiliary_functions/#Load-Data","page":"Auxiliary Functions","title":"Load Data","text":"","category":"section"},{"location":"lib/auxiliary_functions/","page":"Auxiliary Functions","title":"Auxiliary Functions","text":"LoadTXT_asStruct\nParseArray_asFiniteRotation\nParseArray_asEulerVector","category":"page"},{"location":"lib/auxiliary_functions/#PlateKinematics.LoadTXT_asStruct","page":"Auxiliary Functions","title":"PlateKinematics.LoadTXT_asStruct","text":"LoadTXT_asStruct(filePath::String, structType::DataType; names=nothing, header=false, skipstart=0, skipblanks=true, comments=true, comment_char='#')\n\nLoad the content of a TXT file into a struct array. The structType must be one of FiniteRotCart, FiniteRotSph, EulerVectorCart or EulerVectorSph. The names of the columns must be provided in the names argument if header is false. If header is true, the names are extracted from the first row of the file. The skipstart argument is the number of lines to skip at the start of the file. If skipblanks is true, blank lines are skipped. If comments is true, lines starting with the comment_char are skipped.\n\nArguments\n\nfilePath: Path to the TXT file.\nstructType: Type of the struct to be loaded.\nnames: Names of the columns in the file, used as field names in struct constructor. (optional, default: nothing)\nheader: If true, the first row of the file is considered the header. If names is not provided, the header is used as field names. (optional, default: false)\nskipstart: Number of lines to skip at the start of the file. (optional, default: 0)\nskipblanks: If true, blank lines are skipped. (optional, default: true)\ncomments: If true, lines starting with the comment_char are skipped. (optional, default: true)\ncomment_char: Character that indicates a comment line. (optional, default: '#')\n\nReturns\n\nArray of structs of type structType.\n\n\n\n\n\n","category":"function"},{"location":"lib/auxiliary_functions/#PlateKinematics.ParseArray_asFiniteRotation","page":"Auxiliary Functions","title":"PlateKinematics.ParseArray_asFiniteRotation","text":"ParseArray_asFiniteRotation(data::Matrix, names::Union{Vector, Matrix}, structType::DataType)\n\nParse a matrix of data into an array of FiniteRotCart or FiniteRotSph structs. The names of the columns must be provided in the names argument. The structType must be one of FiniteRotCart or FiniteRotSph.\n\nArguments\n\ndata: Matrix of data to be parsed.\nnames: Names of the columns in the data, used as field names in struct constructor.\nstructType: Type of the struct to be loaded. Options are FiniteRotCart or FiniteRotSph.\n\nReturns\n\nArray of structs of type structType.\n\n\n\n\n\n","category":"function"},{"location":"lib/auxiliary_functions/#PlateKinematics.ParseArray_asEulerVector","page":"Auxiliary Functions","title":"PlateKinematics.ParseArray_asEulerVector","text":"ParseArray_asEulerVector(data::Matrix, names::Union{Vector, Matrix}, structType::DataType)\n\nParse a matrix of data into an array of EulerVectorCart or EulerVectorSph structs. The names of the columns must be provided in the names argument. The structType must be one of EulerVectorCart or EulerVectorSph.\n\nArguments\n\ndata: Matrix of data to be parsed.\nnames: Names of the columns in the data, used as field names in struct constructor.\nstructType: Type of the struct to be loaded. Options are EulerVectorCart or EulerVectorSph.\n\nReturns\n\nArray of structs of type structType.\n\n\n\n\n\n","category":"function"},{"location":"lib/auxiliary_functions/#Save-Data","page":"Auxiliary Functions","title":"Save Data","text":"","category":"section"},{"location":"lib/auxiliary_functions/","page":"Auxiliary Functions","title":"Auxiliary Functions","text":"SaveStruct_asTXT","category":"page"},{"location":"lib/auxiliary_functions/#PlateKinematics.SaveStruct_asTXT","page":"Auxiliary Functions","title":"PlateKinematics.SaveStruct_asTXT","text":"SaveStruct_asTXT(array::Writables, filePath::String; delimiter=' '::Char, fields=nothing::Union{Vector, Array, Nothing}, header=true::Bool, format=nothing::Union{Vector, Array, Nothing})\n\nSave a structure to a text file. The function will save the structure in a tabular format.\n\nArguments\n\narray:: An array of structures to save to file. May also be a single structure. Options are FiniteRotCart, FiniteRotSph, EulerVectorCart, EulerVectorSph, SurfaceVelocityVector.\nfilePath: The path to the file to save the structure to.\ndelimiter: The delimiter to use in the text file. Warning, \\t may not work as expected. (optional, default=' ')\nfields: The fields to save to the file. If nothing, all fields will be saved. (optional, default=nothing)\nheader: If true, a header will be added to the file, with the field names of the struct. (optional, default=true)\nformat: The format to save the fields in. If nothing, the default is \"%.5f\" for all columns. (optional, default=nothing)\n\nReturns\n\nNothing\n\n\n\n\n\n","category":"function"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Pages = [\"theory.md\"]\nDepth = 3","category":"page"},{"location":"theory/#General-background","page":"Theory","title":"General background","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Plate tectonics is the scientific theory that describes the motion and interaction between the portions of the outermost layer of the Earth, the lithosphere. This rigid layer is divided into a number of plates, which move relative to each other forming the landscape we see today. The theory is supported by a wide range of evidence, including geological observations, paleomagnetism, and numerical modeling. How these plates move can shed light into the shallow and internal geological processes that shaped our planet over time.","category":"page"},{"location":"theory/#Important-terminology","page":"Theory","title":"Important terminology","text":"","category":"section"},{"location":"theory/#Reference-frame","page":"Theory","title":"Reference frame","text":"","category":"section"},{"location":"theory/#Relative-motion","page":"Theory","title":"Relative motion","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Relative motion refers to the movement of one plate in relation to another. For present day measurement, scientist can resort to GPS (Global Positioning System) geodesy or other satellite observations.  ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"As for motion of plates in the past, scientists can resort to paleomagnetic data to determine the relative motion of plates. As plates diverge in spreading center, new rock is formed. These rocks host magnetic minerals and so record the polarity inversions of our Earth magnetic field. The geographic distance between two polarity inversions on opposite plates at a given point in time can yield the relative motion of the plates.  ","category":"page"},{"location":"theory/#Absolute-motion","page":"Theory","title":"Absolute motion","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Absolute motion describes the movement of a plate relative to a fixed point in space, such as the Earth's center. The most common way to measure absolute motion is by using hotspot tracks, i.e, the volcanic lineations left by pseudo-stationary sources of magma located beneath the Earth's crust. These sources are called mantle plumes, and commonly originate in the deep mantle, a proxy for the Earth's center. As the plates move over the plumes, a trail of volcanic rocks is formed, effectively recording the plate's motion in the past.","category":"page"},{"location":"theory/#Motion-representations","page":"Theory","title":"Motion representations","text":"","category":"section"},{"location":"theory/#Euler-Pole","page":"Theory","title":"Euler Pole","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Pivot point for a rotation in Euclidean geometry. In Spherical geometry, it is point on the surface of the Earth where the axis of rotation of a plate intersects the surface. This axis passes through the center of the Earth and naturally intercepts the surface at two opposite points. It is generally agreed among geoscientists to apply the right-hand rule, where a positive rotation has the thumb pointing towards the Euler Pole, and the fingers curl along the path of the body in motion. The pole on the opposite side is called Anti-pole.","category":"page"},{"location":"theory/#Finite-Rotation","page":"Theory","title":"Finite Rotation","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Rotation by a given angle about a fixed Euler Pole. A Finite Rotation can be described with only three parameters: two describing the geographical location of the Euler Pole, and a third one reporting the rotation angle. ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"It may also be represent as:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Cartesian coordinates of the Euler Pole, and the rotation angle as norm. Keep in mind however, that Finite Rotations are not vectors, and have their own set of mathematical properties. \nA rotation matrix, which is a 3x3 matrix that can be used to rotate a vector in 3D space.  \nA set of three Euler Angles, which are three angles on each mayor axis requires to compose the original rotation.   ","category":"page"},{"location":"theory/#Euler-Vector","page":"Theory","title":"Euler Vector","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Three dimensional rotation vector to describe the relative motion between any two plates. Can be described with three parameters: two describing the location of the Euler Pole, and a third one reporting the rotation rate, assumed to be constant during the time spanned. Euler Vector may also be represented as Cartesian coordinates.    ","category":"page"},{"location":"theory/#Time-Range","page":"Theory","title":"Time Range","text":"","category":"section"},{"location":"theory/#Total-Rotation","page":"Theory","title":"Total Rotation","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Rotations to and from the present are called total rotations. Finite Rotations anchored to the present day means all reference frames are equal, allowing for special algebraic properties, e.g., fixed-plate inversion.","category":"page"},{"location":"theory/#Stage-Rotation","page":"Theory","title":"Stage Rotation","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Report the motion history of a pair of plates over a given time interval. Expressing the motion of a plate in terms of a series stage rotations implies that the Euler Pole has remained fixed during the stage and jumped between successive stages. Unlike total rotations, stage rotations are more delicate to manipulate, and can easily lead to errors when the rules of finite rotations are not respected. An in-depth overview of these rules can be found in the book Plate Tectonics: How it works by Allan Cox.","category":"page"},{"location":"theory/#Time-Orientation","page":"Theory","title":"Time Orientation","text":"","category":"section"},{"location":"theory/#Forward-Rotation","page":"Theory","title":"Forward Rotation","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Rotations going forward in time are called forward rotations. This is the way Euler Vectors are usually represented, as they report a motion rate, which can more easily visualized a plate velocity.","category":"page"},{"location":"theory/#Reconstruction-Rotation","page":"Theory","title":"Reconstruction Rotation","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Is the rotation starting at a more recent point in time and going backwards, reconstructing the previous positions of the plates. ","category":"page"},{"location":"lib/main_functions/","page":"Main Functions","title":"Main Functions","text":"CurrentModule = PlateKinematics","category":"page"},{"location":"lib/main_functions/#Main-Functions","page":"Main Functions","title":"Main Functions","text":"","category":"section"},{"location":"lib/main_functions/","page":"Main Functions","title":"Main Functions","text":"PlateKinematics.jl includes functions to aid in the step between Finite Rotations to Euler Vectors to Surface Velocity. These steps usually involve interpolation and concatenation of Finite Rotations. All functions allow the user to work with (i) sampled ensembles of a Finite Rotations, (ii) an average Finite Rotation from which an ensemble is drawn, or (iii) a single Finite Rotation to which no Covariance has been given. The same principle applies to functions involving Euler Vectors. In many functions you will notice the optional parameter Nsize, which aims at providing control to the user on the size of the sampled ensemble of Finite Rotations/Euler Vector, shall a Covariance be provided.","category":"page"},{"location":"lib/main_functions/#Contents","page":"Main Functions","title":"Contents","text":"","category":"section"},{"location":"lib/main_functions/","page":"Main Functions","title":"Main Functions","text":"Pages = [\"main_functions.md\"]\nDepth = 3","category":"page"},{"location":"lib/main_functions/#Index","page":"Main Functions","title":"Index","text":"","category":"section"},{"location":"lib/main_functions/","page":"Main Functions","title":"Main Functions","text":"Pages = [\"main_functions.md\"]","category":"page"},{"location":"lib/main_functions/#Main-Functions-2","page":"Main Functions","title":"Main Functions","text":"","category":"section"},{"location":"lib/main_functions/#Build-Sampled-Ensembles","page":"Main Functions","title":"Build Sampled Ensembles","text":"","category":"section"},{"location":"lib/main_functions/","page":"Main Functions","title":"Main Functions","text":"BuildEnsemble3D","category":"page"},{"location":"lib/main_functions/#Un-build-Sampled-Ensembles-(Average)","page":"Main Functions","title":"Un-build Sampled Ensembles (Average)","text":"","category":"section"},{"location":"lib/main_functions/","page":"Main Functions","title":"Main Functions","text":"AverageEnsemble","category":"page"},{"location":"lib/main_functions/#PlateKinematics.AverageEnsemble","page":"Main Functions","title":"PlateKinematics.AverageEnsemble","text":"AverageEnsemble(FRsArray::Array{T}, time=nothing::Union{Nothing, Float64}) where {T<:FiniteRotSph}\nAverageEnsemble(FRcArray::Array{T}, time=nothing::Union{Nothing, Float64}) where {T<:FiniteRotCart}\n\nReturn the average Finite Rotation from a given ensemble. A specific output :Time  field may be passed through the argument time. The output type (FiniteRotSph  or FiniteRotCart) will mirror the input array type.\n\n\n\n\n\nAverageEnsemble(EVsArray::Array{T}, timeRange=nothing::Union{Nothing, Matrix}) where {T<:EulerVectorSph}\nAverageEnsemble(EVcArray::Array{T}, timeRange=nothing::Union{Nothing, Matrix}) where {T<:EulerVectorCart}\n\nReturn the average Euler Vector from a given ensemble. A specific output :TimeRange  field may be passed through the argument timeRange. The output type (EulerVectorSph  or EulerVectorCart) will mirror the input array type.\n\n\n\n\n\n","category":"function"},{"location":"lib/main_functions/#Interpolate-Finite-Rotations","page":"Main Functions","title":"Interpolate Finite Rotations","text":"","category":"section"},{"location":"lib/main_functions/","page":"Main Functions","title":"Main Functions","text":"Interpolate_FiniteRotation","category":"page"},{"location":"lib/main_functions/#PlateKinematics.Interpolate_FiniteRotation","page":"Main Functions","title":"PlateKinematics.Interpolate_FiniteRotation","text":"Interpolate_FiniteRotation(FRs1::FiniteRotSph, time::Float64, Nsize=100000::Int64)\nInterpolate_FiniteRotation(FRs1::Array{T}, time::Float64) where {T<:FiniteRotSph}\n\nInterpolate a Finite Fotation for a given time between a Finite Rotation FRs and present-day.\n\n\n\n\n\nInterpolate_FiniteRotation(\n    FRs1::FiniteRotSph, FRs2::FiniteRotSph, time::Float64, Nsize=100000::Int64)\n\nInterpolate_FiniteRotation(\n    FRs1::Array{T}, FRs2::Array{T}, time::Float64) where {T<:FiniteRotSph}\n\nInterpolate a Finite Rotation for a given time between two total Finite Rotations,  a younger FRs1 and an older one FRs2.\n\n\n\n\n\nInterpolate_FiniteRotation(\n    FRsList::Array{T}, times::Array{N}, Nsize=100000::Int64) where {T<:FiniteRotSph, N<:Float64}\n\nInterpolate a list times from a list of total Finite Rotations FRsList.\n\n\n\n\n\nInterpolate_FiniteRotation(MTX::Array{N, 3}, t1::N, time::N) where {N<:Float64}\n\nInterpolate a Finite Fotation for a given time between a Rotation Matrix MTX and present-day. t1 is the age of the Rotation Matrix. MTX may be a sampled  ensemble from BuildEnsemble.\n\n\n\n\n\nInterpolate_FiniteRotation(     MTX1::Array{N, 3}, MTX2::Array{N, 3}, t1::N, t2::N, time::N) where {N<:Float64}\n\nInterpolate a Finite Rotation for a given time between two total Rotation Matrices, a younger MTX1 and an older one MTX2. Rotation Matrices ages are t1 and t2,  respectively. MTX1 and MTX2 may be sampled ensembles from BuildEnsemble.\n\n\n\n\n\n","category":"function"},{"location":"lib/main_functions/#Add-Finite-Rotations","page":"Main Functions","title":"Add Finite Rotations","text":"","category":"section"},{"location":"lib/main_functions/","page":"Main Functions","title":"Main Functions","text":"Add_FiniteRotations","category":"page"},{"location":"lib/main_functions/#PlateKinematics.Add_FiniteRotations","page":"Main Functions","title":"PlateKinematics.Add_FiniteRotations","text":"Add_FiniteRotations(\n    FRs1::FiniteRotSph, FRs2::FiniteRotSph, \n    Nsize=100000::Int64, time=nothing::Union{Nothing, Float64})\n\nAdd_FiniteRotations(\n    FRs1::Array{T}, FRs2::Array{T},\n    time=nothing::Union{Nothing, Float64}) where {T<:FiniteRotSph}\n\nReturn the sumation of two Finite Rotations in Spherical coordinates.  A specific output :Time field may be passed through the argument time.\n\n\n\n\n\n","category":"function"},{"location":"lib/main_functions/#Concatenate-Finite-Rotations","page":"Main Functions","title":"Concatenate Finite Rotations","text":"","category":"section"},{"location":"lib/main_functions/","page":"Main Functions","title":"Main Functions","text":"Concatenate two or more finite rotations into a plate circuit that links two plates. ","category":"page"},{"location":"lib/main_functions/","page":"Main Functions","title":"Main Functions","text":"Concatenate_FiniteRotations","category":"page"},{"location":"lib/main_functions/#PlateKinematics.Concatenate_FiniteRotations","page":"Main Functions","title":"PlateKinematics.Concatenate_FiniteRotations","text":"Concatenate_FiniteRotations(\n    FRsList::Array{T}, Nsize=100000::Int64, \n    time=nothing::Union{Nothing, Float64}) where {T<:FiniteRotSph}\n\nConcatenate_FiniteRotations(\n    FRsList::Array{T}, time=nothing::Union{Nothing, Float64}) where {T<:Array{FiniteRotSph}}\n\nConcatenate all the Finite Rotations in the given array FRsList. A specific output :Time  field may be passed through the argument time. Ensure the list is given in order towards  the fixed reference frame (see Examples - Concatenate Finite Rotations).\n\n\n\n\n\nConcatenate_FiniteRotations(\n    FRs1List::Array{T}, FRs2List::Array{T}, \n    Nsize=100000::Int64, times=[]]::Array{N}) where {T<:FiniteRotSph, N<:Float64}\n\nGiven two lists of Finite Rotations (FRs1List and FRs2List), concatenate the poles for  available common ages. Specific ages may be passed through the argument times.\n\n\n\n\n\n","category":"function"},{"location":"lib/main_functions/","page":"Main Functions","title":"Main Functions","text":"Note that concatenation is nothing more than a summation of every two Finite Rotations in a particular order. Knowing this, one may also use the Add_FiniteRotations function.","category":"page"},{"location":"lib/main_functions/#Finite-Rotations-to-Euler-Vector","page":"Main Functions","title":"Finite Rotations to Euler Vector","text":"","category":"section"},{"location":"lib/main_functions/","page":"Main Functions","title":"Main Functions","text":"ToEulerVector\nToEulerVectorList","category":"page"},{"location":"lib/main_functions/#PlateKinematics.ToEulerVector","page":"Main Functions","title":"PlateKinematics.ToEulerVector","text":"ToEulerVector(FRs::FiniteRotSph, reverseRot=false::Bool, Nsize=100000::Int64)\nToEulerVector(FRsArray::Array{FiniteRotSph}, reverseRot=false::Bool)\n\nReturn a stage Euler Vector describing the Forward Rotation between a total  Finite Rotation FRs and present-day. FRs must represent a Reconstruction Rotation. The output time-orientation may the inverted by setting the reverseRot  parameter to true.\n\n\n\n\n\nToEulerVector(\n    FRs1::FiniteRotSph, FRs2::FiniteRotSph, \n    reverseRot=false::Bool, Nsize=100000::Int64)\nToEulerVector(\n    FRs1Array::Array{T}, FRs2Array::Array{T}, \n    reverseRot=false::Bool) where {T<:FiniteRotSph}\n\nReturn a stage Euler Vector describing the motion between  two total Finite Rotations (FRs1 and FRs2). FRs1 and FRs2 must each represent  a Reconstruction Rotation. If FRs1.Time > FRs2.Time, the resulting Euler Vector will represent a Forward Rotation. The output time-orientation may the inverted by  setting the reverseRot parameter to true.\n\n\n\n\n\n","category":"function"},{"location":"lib/main_functions/#PlateKinematics.ToEulerVectorList","page":"Main Functions","title":"PlateKinematics.ToEulerVectorList","text":"ToEulerVectorList(\n    FRsArray::Array{T}, reverseRot=false::Bool, Nsize=100000::Int64) where {T<:FiniteRotSph}\n\nReturn a list of Euler Vectors describing the motion for a list of total Finite Rotations FRsArray. The output time-orientation may the inverted by setting the reverseRot parameter to true.\n\n\n\n\n\n","category":"function"},{"location":"lib/main_functions/#Euler-Vector-de-Finite-Rotation","page":"Main Functions","title":"Euler Vector de Finite Rotation","text":"","category":"section"},{"location":"lib/main_functions/","page":"Main Functions","title":"Main Functions","text":"ToFiniteRotation","category":"page"},{"location":"lib/main_functions/#PlateKinematics.ToFiniteRotation","page":"Main Functions","title":"PlateKinematics.ToFiniteRotation","text":"ToFiniteRotation(EVs::EulerVectorSph, reverseRot=false::Bool, Nsize=100000::Int64)\nToFiniteRotation(EVsArray::Array{T}, reverseRot=false::Bool) where {T<:EulerVectorSph}\n\nReturn a total Finite Rotation from a total Euler Vector EVs. The output time-orientation  may the inverted by setting the reverseRot parameter to true.\n\n\n\n\n\n","category":"function"},{"location":"lib/main_functions/#Calculate-Surface-Velocity","page":"Main Functions","title":"Calculate Surface Velocity","text":"","category":"section"},{"location":"lib/main_functions/","page":"Main Functions","title":"Main Functions","text":"Calculate_SurfaceVelocity","category":"page"},{"location":"lib/main_functions/#PlateKinematics.Calculate_SurfaceVelocity","page":"Main Functions","title":"PlateKinematics.Calculate_SurfaceVelocity","text":"Calculate_SurfaceVelocity(\n    EVs::EulerVectorSph, pntLon::Float64, pntLat::Float64, Nsize=100000::Int64)\n\nCalculate_SurfaceVelocity(\n    EVsArray::Array{T}, pntLon::Float64, pntLat::Float64) where {T<:EulerVectorSph}\n\nCalculate_SurfaceVelocity(\n    EVs::EulerVectorSph, arrayLon::Array{N}, arrayLat::Array{N}, \n    Nsize=100000::Int64) where {N<:Float64}\n\nCalculate the Surface Velocity components for a given point on Earth, subject to the motion described by an Euler Vector EVs. Location(s) are given through parameters pntLon  and pntLat, which represent spherical coordinates in degrees-East and degrees-North,  respectively. Outputs are given in cm/yr and degrees.\t\n\n\n\n\n\n","category":"function"},{"location":"lib/types/","page":"Types","title":"Types","text":"CurrentModule = PlateKinematics","category":"page"},{"location":"lib/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"This section provides an overview of the types used in PlateKinematics.jl.","category":"page"},{"location":"lib/types/#Contents","page":"Types","title":"Contents","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"Pages = [\"types.md\"]\nDepth = 3","category":"page"},{"location":"lib/types/#Index","page":"Types","title":"Index","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"Pages = [\"types.md\"]","category":"page"},{"location":"lib/types/#Types-2","page":"Types","title":"Types","text":"","category":"section"},{"location":"lib/types/#Covariance","page":"Types","title":"Covariance","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"Covariance","category":"page"},{"location":"lib/types/#PlateKinematics.Covariance","page":"Types","title":"PlateKinematics.Covariance","text":"struct Covariance\n\nCovariance upper triangle elements. Expressed in radians² for Finite Rotations and in radians²/Myr² for Euler Vectors.\n\nExamples:\n\njulia> PlateKinematics.Covariance()\nPlateKinematics.Covariance(0, 0, 0, 0, 0, 0)\n\njulia> PlateKinematics.Covariance(1, 2, 3, 4, 5, 6)\nPlateKinematics.Covariance(1, 2, 3, 4, 5, 6)\n\njulia> array = [1, 2, 3, 4, 5, 6];\njulia> PlateKinematics.Covariance(array)\nPlateKinematics.Covariance(1, 2, 3, 4, 5, 6)\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#Finite-Rotations","page":"Types","title":"Finite Rotations","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"FiniteRotSph\nFiniteRotCart\nEulerAngles","category":"page"},{"location":"lib/types/#PlateKinematics.FiniteRotSph","page":"Types","title":"PlateKinematics.FiniteRotSph","text":"struct FiniteRotSph\n\nFinite rotation in Spherical coordinates, expressed in degrees.\n\nFields\n\nLon::Float64: Longitude of the rotation axis in degrees-East\nLat::Float64: Latitude of the rotation axis in degrees-North\nAngle::Float64: Angle of rotation in degrees\nTime::Union{Float64, Nothing}: Age of rotation in million years\nCovariance::Covariance: Covariance in radians²\n\nExamples:\n\njulia> PlateKinematics.FiniteRotSph(30, 20, 10)\nPlateKinematics.FiniteRotSph:\n        Lon        : 30.0\n        Lat        : 20.0\n        Angle      : 10.0\n        Time       : nothing\n        Covariance : PlateKinematics.Covariance(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n\njulia> array = [30, 20, 10];\njulia> PlateKinematics.FiniteRotSph(array)\nPlateKinematics.FiniteRotSph:\n        Lon        : 30.0\n        Lat        : 20.0\n        Angle      : 10.0\n        Time       : nothing\n        Covariance : PlateKinematics.Covariance(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n\njulia> PlateKinematics.FiniteRotSph(30, 20, 10, 2)\nPlateKinematics.FiniteRotSph:\n        Lon        : 30.0\n        Lat        : 20.0\n        Angle      : 10.0\n        Time       : 2.0\n        Covariance : PlateKinematics.Covariance(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n\njulia> array = [1, 2, 3, 4, 5, 6];\njulia> PlateKinematics.FiniteRotSph(30, 20, 10, array)\nPlateKinematics.FiniteRotSph(30, 20, 10, nothing, PlateKinematics.Covariance(1, 2, 3, 4, 5, 6))\n\njulia> array = [1, 2, 3, 4, 5, 6];\njulia> PlateKinematics.FiniteRotSph(30, 20, 10, 2, array)\nPlateKinematics.FiniteRotSph:\n        Lon        : 30.0\n        Lat        : 20.0\n        Angle      : 10.0\n        Time       : 2.0\n        Covariance : PlateKinematics.Covariance(1.0, 2.0, 3.0, 4.0, 5.0, 6.0)\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#PlateKinematics.FiniteRotCart","page":"Types","title":"PlateKinematics.FiniteRotCart","text":"struct FiniteRotCart\n\nFinite rotation in Cartesian coordinates, expressed in degrees.\n\nFields\n\nX::Float64: X-coordinate in degrees\nY::Float64: Y-coordinate in degrees\nZ::Float64: Z-coordinate in degrees\nTimeRange::Union{Float64, Nothing}: Age of rotation in million years\nCovariance::Covariance: Covariance in radians²\n\nExamples:\n\njulia> PlateKinematics.FiniteRotCart(1, 2, 3)\nPlateKinematics.FiniteRotCart:\n        X          : 1.0\n        Y          : 2.0\n        Z          : 3.0\n        Time       : nothing\n        Covariance : PlateKinematics.Covariance(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n\njulia> array = [30, 20, 10];\njulia> PlateKinematics.FiniteRotCart(array)\nPlateKinematics.FiniteRotCart:\n        X          : 30.0\n        Y          : 20.0\n        Z          : 10.0\n        Time       : nothing\n        Covariance : PlateKinematics.Covariance(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n\njulia> PlateKinematics.FiniteRotCart(1, 2, 3, 1.5)\nPlateKinematics.FiniteRotCart:\n        X          : 1.0\n        Y          : 2.0\n        Z          : 3.0\n        Time       : 1.5\n        Covariance : PlateKinematics.Covariance(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n\njulia> array = [1, 2, 3, 4, 5, 6];\njulia> PlateKinematics.FiniteRotCart(30, 20, 10, array)\nPlateKinematics.FiniteRotCart:\n        X          : 30.0\n        Y          : 20.0\n        Z          : 10.0\n        Time       : nothing\n        Covariance : PlateKinematics.Covariance(1.0, 2.0, 3.0, 4.0, 5.0, 6.0)\n\njulia> array = [1, 2, 3, 4, 5, 6];\njulia> PlateKinematics.FiniteRotCart(1, 2, 3, 1.5, array)\nPlateKinematics.FiniteRotCart:\n        X          : 1.0\n        Y          : 2.0\n        Z          : 3.0\n        Time       : 1.5\n        Covariance : PlateKinematics.Covariance(1.0, 2.0, 3.0, 4.0, 5.0, 6.0)\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#PlateKinematics.EulerAngles","page":"Types","title":"PlateKinematics.EulerAngles","text":"struct EulerAngles\n\nEuler angles that describe the rotation around the three main axes on Earth.\n\nFields\n\nX::Float64: Angle of rotation around the X-axis (0N, 0E)\nY::Float64: Angle of rotation around the Y-axis (0N, 90E)\nZ::Float64: Angle of rotation around the Z-axis (90N, 0E)\n\nExamples:\n\njulia> PlateKinematics.EulerAngles(4, 5, 6)\nPlateKinematics.EulerAngles:\n        X : 4.0\n        Y : 5.0\n        Z : 6.0\n\njulia> array = [4, 5, 6];\njulia> PlateKinematics.EulerAngles(array)\nPlateKinematics.EulerAngles:\n        X : 4.0\n        Y : 5.0\n        Z : 6.0\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#Euler-Vectors","page":"Types","title":"Euler Vectors","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"EulerVectorSph\nEulerVectorCart","category":"page"},{"location":"lib/types/#PlateKinematics.EulerVectorSph","page":"Types","title":"PlateKinematics.EulerVectorSph","text":"struct EulerVectorSph\n\nEuler vector in spherical coordinates with the following parameters:\n\nFields\n\nLon::Float64: Longitude of the Euler pole in degrees-East\nLat::Float64: Latitude of the Euler pole in degrees-North\nAngVelocity::Float64: Angular velocity in degrees/Myr\nTimeRange::Union{Matrix, Nothing}: Initial to final age of rotation\nCovariance::Covariance: Covariance in radians²/Myr²\n\nExamples:\n\njulia> PlateKinematics.EulerVectorSph(1, 2, 3)\nPlateKinematics.EulerVectorSph:\n        Lon         : 1.0\n        Lat         : 2.0\n        AngVelocity : 3.0\n        TimeRange   : nothing\n        Covariance  : PlateKinematics.Covariance(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n\njulia> array = [30, 20, 10];\njulia> PlateKinematics.EulerVectorSph(array)\nPlateKinematics.EulerVectorSph:\n        Lon         : 30.0\n        Lat         : 20.0\n        AngVelocity : 10.0\n        TimeRange   : nothing\n        Covariance  : PlateKinematics.Covariance(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n\njulia> array = [1.5 2.5];\njulia> length(array) == 2\ntrue\njulia> PlateKinematics.EulerVectorSph(30, 20, 10, array)\nPlateKinematics.EulerVectorSph:\n        Lon         : 30.0\n        Lat         : 20.0\n        AngVelocity : 10.0\n        TimeRange   : [1.5 2.5]\n        Covariance  : PlateKinematics.Covariance(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n\njulia> array = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0];\njulia> length(array) != 2\ntrue\njulia> PlateKinematics.EulerVectorSph(30, 20, 10, array)\nPlateKinematics.EulerVectorSph:\n        Lon         : 30.0\n        Lat         : 20.0\n        AngVelocity : 10.0\n        TimeRange   : nothing\n        Covariance  : PlateKinematics.Covariance(1.0, 2.0, 3.0, 4.0, 5.0, 6.0)\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#PlateKinematics.EulerVectorCart","page":"Types","title":"PlateKinematics.EulerVectorCart","text":"struct EulerVectorCart\n\nEuler vector in Cartesian coordinates, expressed in degrees/Myr.\n\nFields\n\nX::Float64: X-coordinate in degrees/Myr\nY::Float64: Y-coordinate in degrees/Myr\nZ::Float64: Z-coordinate in degrees/Myr\nTimeRange::Union{Matrix, Nothing}: Initial to final age of rotation\nCovariance::Covariance: Covariance in radians²/Myr²\n\nExamples:\n\nSame outer Constructor Methods as EulerVectorSph.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#Surface-Velocity","page":"Types","title":"Surface Velocity","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"Stat\nSurfaceVelocityVector","category":"page"},{"location":"lib/types/#PlateKinematics.Stat","page":"Types","title":"PlateKinematics.Stat","text":"struct Stat\n\nMean and standard deviation of a parameter:\n\nFields\n\nMean::Float64: Mean (average)\nStDev::Float64: Standard deviation\n\nExamples:\n\njulia> PlateKinematics.Stat(10.0, 20.0)\nPlateKinematics.Stat:\n        Mean  : 10.0\n        StDev : 20.0\n\njulia> stat = [10.0 20.0]\njulia> PlateKinematics.Stat(stat)\nPlateKinematics.Stat:\n        Mean  : 10.0\n        StDev : 20.0\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#PlateKinematics.SurfaceVelocityVector","page":"Types","title":"PlateKinematics.SurfaceVelocityVector","text":"struct SurfaceVelocityVector\n\nSurface velocity vector components, expressed in mm/yr.\n\nFields\n\nLon::Float64: Longitude of the surface point in degrees-East\nLat::Float64: Latitude of the surface point in degrees-North\nEastVel::Union{Float64, Stat, Nothing}: East-component of the velocity in mm/yr\nNorthVel::Union{Float64, Stat, Nothing}: North-component of the velocity in mm/yr\nTotalVel::Union{Float64, Stat, Nothing}: Total velocity in mm/yr\nAzimuth::Union{Float64, Stat, Nothing}: Azimuth of the velocity vector as measured clockwise from the North\n\nExamples:\n\njulia> PlateKinematics.SurfaceVelocityVector(10.0, 20.0, 4.0)\nPlateKinematics.SurfaceVelocityVector:\n        Lon      : 10.0\n        Lat      : 20.0\n        EastVel  : nothing\n        NorthVel : nothing\n        TotalVel : 4.0\n        Azimuth  : nothing\n\njulia> PlateKinematics.SurfaceVelocityVector(10, 20, [2.5, 2])\nPlateKinematics.SurfaceVelocityVector:\n        Lon      : 10.0\n        Lat      : 20.0\n        EastVel  : nothing\n        NorthVel : nothing\n        TotalVel : 2.5 ± 2.0\n        Azimuth  : nothing\n\njulia> PlateKinematics.SurfaceVelocityVector(10.0, 20.0, 4.0, 3.0)\nPlateKinematics.SurfaceVelocityVector:\n        Lon      : 10.0\n        Lat      : 20.0\n        EastVel  : 4.0\n        NorthVel : 3.0\n        TotalVel : nothing\n        Azimuth  : nothing\n\njulia> PlateKinematics.SurfaceVelocityVector(10.0, 20.0, 4.0, 3.0, 2.0)\nPlateKinematics.SurfaceVelocityVector:\n        Lon      : 10.0\n        Lat      : 20.0\n        EastVel  : 4.0\n        NorthVel : 3.0\n        TotalVel : 2.0\n        Azimuth  : nothing\n\n\n\n\n\n","category":"type"},{"location":"lib/private_functions/","page":"Private Functions","title":"Private Functions","text":"CurrentModule = PlateKinematics","category":"page"},{"location":"lib/private_functions/#Private-Functions","page":"Private Functions","title":"Private Functions","text":"","category":"section"},{"location":"lib/private_functions/#Contents","page":"Private Functions","title":"Contents","text":"","category":"section"},{"location":"lib/private_functions/","page":"Private Functions","title":"Private Functions","text":"Pages = [\"private_functions.md\"]\nDepth = 3","category":"page"},{"location":"lib/private_functions/#Index","page":"Private Functions","title":"Index","text":"","category":"section"},{"location":"lib/private_functions/","page":"Private Functions","title":"Private Functions","text":"Pages = [\"private_functions.md\"]","category":"page"},{"location":"lib/private_functions/#Private-Functions-2","page":"Private Functions","title":"Private Functions","text":"","category":"section"},{"location":"lib/private_functions/#Covariance-related-functions","page":"Private Functions","title":"Covariance-related functions","text":"","category":"section"},{"location":"lib/private_functions/","page":"Private Functions","title":"Private Functions","text":"CorrelatedEnsemble3D\nCovIsZero\nCheckCovariance\nCovToMatrix\nReplaceCovariaceEigs\nToArray","category":"page"},{"location":"lib/private_functions/#PlateKinematics.CorrelatedEnsemble3D","page":"Private Functions","title":"PlateKinematics.CorrelatedEnsemble3D","text":"CorrelatedEnsemble3D(matrix::Array{N, 2}, Nsize::Int64) where {N<:Float64}\n\nGenerates a series of samples [x y z] based on a covariance matrix.\n\n\n\n\n\n","category":"function"},{"location":"lib/private_functions/#PlateKinematics.CovIsZero","page":"Private Functions","title":"PlateKinematics.CovIsZero","text":"CovIsZero(cov::Covariance)\n\nCheck whether all Covariance elements are zero. \n\n\n\n\n\n","category":"function"},{"location":"lib/private_functions/#PlateKinematics.CheckCovariance","page":"Private Functions","title":"PlateKinematics.CheckCovariance","text":"CheckCovariance(covMatrix::Array{N, 2}) where {N<:Float64}\n\nCheck whether the covariance matrix yields any negative or imaginary eigenvalue.\n\n\n\n\n\n","category":"function"},{"location":"lib/private_functions/#PlateKinematics.CovToMatrix","page":"Private Functions","title":"PlateKinematics.CovToMatrix","text":"CovToMatrix(FR::Union{FiniteRotSph, FiniteRotCart})\n\nConverts a Finite Rotations Covariance structure [radians^2] to a 3x3 symmetric Matrix [radians^2]. \n\n\n\n\n\nCovToMatrix(EVs::Union{EulerVectorSph, EulerVectorCart})\n\nConvert an Euler Vector Covariance structure [radians²/Myr²] to a 3x3 symmetric Matrix [degrees²/Myr²]. \n\n\n\n\n\n","category":"function"},{"location":"lib/private_functions/#PlateKinematics.ReplaceCovariaceEigs","page":"Private Functions","title":"PlateKinematics.ReplaceCovariaceEigs","text":"ReplaceCovariaceEigs(covMatrix::Array{N, 2}) where {N<:Float64}\n\nChecks if a covariance-matrix has negative or imaginary eigenvalues, and replace  the diagonal elements (variances) with an average of the positive eigenvalues, while the other elements (covariances) are replaced by zeros.\n\n\n\n\n\n","category":"function"},{"location":"lib/private_functions/#PlateKinematics.ToArray","page":"Private Functions","title":"PlateKinematics.ToArray","text":"ToArray(cov::Covariance)\n\nConvert a Covariance structure to a 1x6 Matrix. \n\n\n\n\n\n","category":"function"},{"location":"lib/private_functions/#Mutate-Structs","page":"Private Functions","title":"Mutate Structs","text":"","category":"section"},{"location":"lib/private_functions/","page":"Private Functions","title":"Private Functions","text":"ChangeLon\nChangeLat\nChangeAngle\nChangeTime\nChangeCovariance","category":"page"},{"location":"lib/private_functions/#PlateKinematics.ChangeLon","page":"Private Functions","title":"PlateKinematics.ChangeLon","text":"ChangeLon(FRs::FiniteRotSph, newLon::Float64)\n\nChange the :Lon (longitude) value of FRs with newLon.\n\n\n\n\n\n","category":"function"},{"location":"lib/private_functions/#PlateKinematics.ChangeLat","page":"Private Functions","title":"PlateKinematics.ChangeLat","text":"ChangeLat(FRs::FiniteRotSph, newLat::Float64)\n\nChange the :Lat (latitude) value of FRs with newLat.\n\n\n\n\n\n","category":"function"},{"location":"lib/private_functions/#PlateKinematics.ChangeAngle","page":"Private Functions","title":"PlateKinematics.ChangeAngle","text":"ChangeAngle(FRs::FiniteRotSph, newAngle::Float64)\n\nChange the :Angle (angle) value of FRs with newAngle.\n\n\n\n\n\n","category":"function"},{"location":"lib/private_functions/#PlateKinematics.ChangeTime","page":"Private Functions","title":"PlateKinematics.ChangeTime","text":"ChangeTime(FRs::FiniteRotSph, newTime::Float64)\n\nChange the :Time (rotation age) value of FRs with newTime.\n\n\n\n\n\n","category":"function"},{"location":"lib/private_functions/#PlateKinematics.ChangeCovariance","page":"Private Functions","title":"PlateKinematics.ChangeCovariance","text":"ChangeCovariance(\n    FRs::FiniteRotSph, newCovariance::Union{Covariance, Array{N}}) where {N<:Float64}\n\nChange the ::Covariance (covariance elements) of FRs with newCovariance.\n\n\n\n\n\n","category":"function"},{"location":"lib/private_functions/#Others","page":"Private Functions","title":"Others","text":"","category":"section"},{"location":"lib/private_functions/","page":"Private Functions","title":"Private Functions","text":"CartesianVelocity_toEN\nGeographicalCoords_toCartesian","category":"page"},{"location":"lib/private_functions/#PlateKinematics.CartesianVelocity_toEN","page":"Private Functions","title":"PlateKinematics.CartesianVelocity_toEN","text":"CartesianVelocity_toEN(pntLon::N, pntLat::N, SVcArray::Array{N, 2}) where {N<:Float64}\n\nConverts a set of velocities from Cartesian to East/North (EN) components. \n\n\n\n\n\n","category":"function"},{"location":"lib/private_functions/#PlateKinematics.GeographicalCoords_toCartesian","page":"Private Functions","title":"PlateKinematics.GeographicalCoords_toCartesian","text":"GeographicalCoords_toCartesian(pntLon::Float64, pntLat::Float64, Ht=0.0::Float64)\n\nConverts local geographical coordinates (ellipsoidal) into Cartesian. \n\n\n\n\n\n","category":"function"},{"location":"examples/mf_interpolate/","page":"Interpolate Finite Rotations","title":"Interpolate Finite Rotations","text":"CurrentModule = PlateKinematics","category":"page"},{"location":"examples/mf_interpolate/#Concatenate-Finite-Rotations","page":"Interpolate Finite Rotations","title":"Concatenate Finite Rotations","text":"","category":"section"},{"location":"examples/mf_interpolate/","page":"Interpolate Finite Rotations","title":"Interpolate Finite Rotations","text":"Lest take for instance a direct example from Allan Cox' book Plate Tectonics: How it works for the motion of the Australian plate with respect to the Antarctic plate. We are provided with total finite rotations (Table 7-3) for the ages 37 and 42 Ma (mega-annun, meaning million years before present):","category":"page"},{"location":"examples/mf_interpolate/","page":"Interpolate Finite Rotations","title":"Interpolate Finite Rotations","text":"t(Ma) Longitude(°E) Latitude(°N) Angle(°)\n37.0 34.4 11.9 -20.5\n42.0 34.8 10.3 -23.6","category":"page"},{"location":"examples/mf_interpolate/","page":"Interpolate Finite Rotations","title":"Interpolate Finite Rotations","text":"However, we wish the Finite Rotation for the age of 40 Ma, requiring us to interpolate:","category":"page"},{"location":"examples/mf_interpolate/","page":"Interpolate Finite Rotations","title":"Interpolate Finite Rotations","text":"using PlateKinematics\nusing PlateKinematics: FiniteRotSph, Covariance\nusing PlateKinematics: Interpolate_FiniteRotation\n\nFRs_37 = FiniteRotSph(34.4, 11.9, -20.5, 37.0);\nFRs_42 = FiniteRotSph(34.8, 10.3, -23.6, 42.0);\nInterpolate_FiniteRotation(FRs_37, FRs_42, 40.0)","category":"page"},{"location":"examples/mf_interpolate/","page":"Interpolate Finite Rotations","title":"Interpolate Finite Rotations","text":"The output finite rotation will be something in the lines of:","category":"page"},{"location":"examples/mf_interpolate/","page":"Interpolate Finite Rotations","title":"Interpolate Finite Rotations","text":"FiniteRotSph:\n        Lon     : -145.35\n        Lat     : -10.89\n        Angle   : 22.36\n        Time    : 40.0\n        Covariance : Covariance(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)","category":"page"},{"location":"examples/mf_interpolate/","page":"Interpolate Finite Rotations","title":"Interpolate Finite Rotations","text":"Similarly, one may interpolate between one finite rotation and present-day, shall we lack a younger constrain for the desired motion. For instance, we may wish interpolate the motion of the Australian plate at 30 Ma:","category":"page"},{"location":"examples/mf_interpolate/","page":"Interpolate Finite Rotations","title":"Interpolate Finite Rotations","text":"Interpolate_FiniteRotation(FRs_37, 30.0)","category":"page"},{"location":"examples/mf_interpolate/","page":"Interpolate Finite Rotations","title":"Interpolate Finite Rotations","text":"FiniteRotSph:\n        Lon        : -145.6\n        Lat        : -11.9\n        Angle      : 16.62\n        Time       : 30.0\n        Covariance : Covariance(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)","category":"page"},{"location":"examples/mf_interpolate/","page":"Interpolate Finite Rotations","title":"Interpolate Finite Rotations","text":"For such cases, the Euler Pole will remain the same, but the angle will be linearly interpolated. ","category":"page"},{"location":"examples/mf_concatenate/","page":"Concatenate Finite Rotations","title":"Concatenate Finite Rotations","text":"CurrentModule = PlateKinematics","category":"page"},{"location":"examples/mf_concatenate/#Concatenate-Finite-Rotations","page":"Concatenate Finite Rotations","title":"Concatenate Finite Rotations","text":"","category":"section"},{"location":"examples/mf_concatenate/","page":"Concatenate Finite Rotations","title":"Concatenate Finite Rotations","text":"At time it may be useful to obtain the relative motion between two plates that do not share a divergent margin, or no boundary at all for that matter. The lack of common fracture zones and isochrons produces by a shared spreading center prevents the direct observation of the relative tectonic history between both plates. ","category":"page"},{"location":"examples/mf_concatenate/","page":"Concatenate Finite Rotations","title":"Concatenate Finite Rotations","text":"This obstacle can be circumvented by using a plate circuit that links both plates, say India and Eurasia, by a series of well-defined relative plate motion reconstructions. To connect the India plate to the Eurasian one, one may use the total reconstruction poles of Eurasia/North-America, North-America/Nubia, Africa/Antarctica, Antarctica/Australia and Australia/India.","category":"page"},{"location":"examples/mf_concatenate/","page":"Concatenate Finite Rotations","title":"Concatenate Finite Rotations","text":"This examples is taken from the book Plate Tectonics: How it works from Allan Cox, and provides on how to calculate the relative motion between plates that do not share a divergent boundary. All the other plate-pairs mentioned do share a common spreading center, which allows researcher to estimate opening rates of the ocean floor from the magnetic lineations parallel to the ridge.","category":"page"},{"location":"examples/mf_concatenate/","page":"Concatenate Finite Rotations","title":"Concatenate Finite Rotations","text":"<center> <img src=\"../assets/plate_circuit.png\" alt=\"Plate circuit example\" width=\"600\"> </center>","category":"page"},{"location":"examples/mf_concatenate/","page":"Concatenate Finite Rotations","title":"Concatenate Finite Rotations","text":"Plate circuit example. Modified from Plate Tectonics: How it works.","category":"page"},{"location":"examples/mf_concatenate/","page":"Concatenate Finite Rotations","title":"Concatenate Finite Rotations","text":"In terms of Finite Rotations (FR), one would pose the circuit as:","category":"page"},{"location":"examples/mf_concatenate/","page":"Concatenate Finite Rotations","title":"Concatenate Finite Rotations","text":"FR<sub>IN/EU</sub> = FR<sub>IN/AU</sub> + FR<sub>AU/AN</sub> + FR<sub>AN/NB</sub> + FR<sub>NB/NA</sub> + FR<sub>NA/EU</sub> <br/><br/>","category":"page"},{"location":"examples/mf_concatenate/","page":"Concatenate Finite Rotations","title":"Concatenate Finite Rotations","text":"In the posed equation, the fixed coordinate system was chosen to be Eurasia. This is also indicated with the subscripts on each individual relative motion, indicating both the moving and the fixed plate. For instance: ","category":"page"},{"location":"examples/mf_concatenate/","page":"Concatenate Finite Rotations","title":"Concatenate Finite Rotations","text":"FR<sub>IN/EU</sub> <br/>","category":"page"},{"location":"examples/mf_concatenate/","page":"Concatenate Finite Rotations","title":"Concatenate Finite Rotations","text":"is the finite rotation describing the motion of India relative to a fixed Eurasia plate.","category":"page"},{"location":"examples/mf_concatenate/","page":"Concatenate Finite Rotations","title":"Concatenate Finite Rotations","text":"The equation is solved by performing each summation one by one, from left to right, adding relative motions from the moving plate towards the fixed reference frame. Following the books example, we want to find the position of India relative to Eurasia at 40 Ma. Total reconstruction poles available may not include the 40 Ma rotation:","category":"page"},{"location":"examples/mf_concatenate/","page":"Concatenate Finite Rotations","title":"Concatenate Finite Rotations","text":"<table>\n    <thead>\n        <tr>\n            <th></th>\n            <th>t(Ma)</th>\n            <th>Longitude(°E)</th>\n            <th>Latitude(°N)</th>\n            <th>Angle(°)</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr style=\"border-bottom: 1px solid black;\">\n        <tr>\n            <td>AU/IN</td>\n            <td>50.0</td>\n            <td>-</td>\n            <td>-</td>\n            <td>0.0</td>\n        </tr>\n        <tr>\n            <td rowspan=2>AN/AU</td>\n            <td>37.0</td>\n            <td>34.4</td>\n            <td>11.9</td>\n            <td>-20.5</td>\n        </tr>\n        <tr>\n            <td>42.0</td>\n            <td>34.8</td>\n            <td>10.3</td>\n            <td>-23.6</td>\n        </tr>\n        <tr>\n            <td>NB/AN</td>\n            <td>40.0</td>\n            <td>322.8</td>\n            <td>5.8</td>\n            <td>7.2</td>\n        </tr>\n        <tr>\n            <td rowspan=2>NB/NA</td>\n            <td>37.0</td>\n            <td>341.3</td>\n            <td>70.5</td>\n            <td>10.4</td>\n        </tr>\n        <tr>\n            <td>66.0</td>\n            <td>351.4</td>\n            <td>80.8</td>\n            <td>22.5</td>\n        </tr>\n        <tr>\n            <td rowspan=2>NA/EU</td>\n            <td>37.0</td>\n            <td>129.9</td>\n            <td>68.0</td>\n            <td>-7.8</td>\n        </tr>\n        <tr>\n            <td>48.0</td>\n            <td>142.8</td>\n            <td>50.8</td>\n            <td>-9.8</td>\n        </tr>\n        <tr style=\"border-bottom: 1px solid black;\">\n    </tbody>\n</table>\n<br/>","category":"page"},{"location":"examples/mf_concatenate/","page":"Concatenate Finite Rotations","title":"Concatenate Finite Rotations","text":"And indeed, some poles will require interpolation (e.g., AU/AN, NB/NA, NA/EU):","category":"page"},{"location":"examples/mf_concatenate/","page":"Concatenate Finite Rotations","title":"Concatenate Finite Rotations","text":"using PlateKinematics\nusing PlateKinematics: FiniteRotSph, Interpolate_FiniteRotation\n\nFRs_AU_AN_37 = FiniteRotSph(34.4, 11.9, -20.5, 37.0);\nFRs_AU_AN_42 = FiniteRotSph(34.8, 10.3, -23.6, 42.0);\nFRs_AU_AN_40 = Interpolate_FiniteRotation(FRs_AU_AN_37, FRs_AU_AN_42, 40.0)","category":"page"},{"location":"examples/mf_concatenate/","page":"Concatenate Finite Rotations","title":"Concatenate Finite Rotations","text":"FiniteRotSph:\n        Lon        : -145.35\n        Lat        : -10.89\n        Angle      : 22.36\n        Time       : 40.0\n        Covariance : PlateKinematics.Covariance(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)","category":"page"},{"location":"examples/mf_concatenate/","page":"Concatenate Finite Rotations","title":"Concatenate Finite Rotations","text":"Once we have obtained all total reconstruction poles for 40 Ma, we concatenate into a plate circuit. Note that, according to literature, no motion was registered between Australia and India prior to 50 Ma. This rotation is therefore ignored, as no relative motion is contributed to the end rotation.  ","category":"page"},{"location":"examples/mf_concatenate/","page":"Concatenate Finite Rotations","title":"Concatenate Finite Rotations","text":"using PlateKinematics: Concatenate_FiniteRotations\n\nFRs_IN_AU_40 = nothing;\nFRs_AU_AN_40 = FiniteRotSph(-145.35, -10.89, 22.36, 40.0);\nFRs_AN_AF_40 = FiniteRotSph(322.8, 5.8, 7.2, 40.0);\nFRs_AF_NA_40 = FiniteRotSph(162.38, -72.57, 11.62, 40.0);\nFRs_NA_EU_40 = FiniteRotSph(135.62, 62.65, 8.25, 40.0);\n\nFRsList = [\n    FRs_AU_AN_40,\n    FRs_AN_AF_40,\n    FRs_AF_NA_40,\n    FRs_NA_EU_40,\n];\n\nFRs_EU_IN_40 = Concatenate_FiniteRotations(FRsList)","category":"page"},{"location":"examples/mf_concatenate/","page":"Concatenate Finite Rotations","title":"Concatenate Finite Rotations","text":"FiniteRotSph:\n        Lon        : -145.1\n        Lat        : -17.21\n        Angle      : 24.35\n        Time       : nothing\n        Covariance : PlateKinematics.Covariance(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A user-friendly tools for easy handling of Plate Kinematics functions with Julia 🌏 📐","category":"page"},{"location":"#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"PlateKinematics is a package aimed at providing types, functions and documentation for working with Finite Rotations, Euler Vectors and Surface Velocities. The knowledge builds from the framework layed down by Allan Cox in his book Plate Tectonics: How It Works.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To install, use Julia's built-in package manager (accessed by pressing ] in the Julia REPL command prompt)  to add the package and also to instantiate/build all the required dependencies.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Pkg\njulia> Pkg.add(\"PlateKinematics\")","category":"page"},{"location":"#Getting-started","page":"Introduction","title":"Getting started","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using PlateKinematics\njulia> ?PlateKinematics","category":"page"}]
}
